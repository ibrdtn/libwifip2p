/*
 * SupplicantHandle.h
 *
 *  Created on: 12.12.2012
 *      Author: morgenro
 *      		niels_w
 */

#ifndef SUPPLICANTHANDLE_H_
#define SUPPLICANTHANDLE_H_

#include <list>
#include <set>
#include <vector>
#include <string>

#include <iostream>

#include "wifip2p/Peer.h"
#include "wifip2p/Connection.h"
#include "wifip2p/WifiP2PInterface.h"
#include "wifip2p/Logger.h"

namespace wifip2p
{
	class SupplicantHandleException : public std::exception
	{
	public:
		SupplicantHandleException(const std::string &what) : _what(what)
		{
		}

		virtual ~SupplicantHandleException() throw ()
		{
		}

		const std::string& what()
		{
			return _what;
		}

	private:
		const std::string _what;
	};

	class SupplicantHandle
	{
	public:
		SupplicantHandle(bool monitor, Logger &logger);
		virtual ~SupplicantHandle();

		/**
		 * Tries to open a control connection to a running wpa_s control_i/f.
		 *
		 * @*ctrl_path: Here, _handle gets assigned, representing the now opened
		 * 				 control_i/f of wpa_s as expected behind the *ctrl_path
		 * 				 parameter.
		 * 				 E.g. when wpa_s is bound to hardware interface wlan0,
		 * 				 fully qualified *ctrl_path needs to match
		 * 				 "/var/run/wpa_supplicant/wlan0"
		 */
		void open(const char *ctrl_path) throw (SupplicantHandleException);

		/**
		 * Initializes wpa_s beyond *_handle, i.e. sets the respective device
		 * 	name through cfg/mac80211, flushes all yet registered services and
		 * 	adds all services as handed over with list<std::string> services.
		 *
		 * @name: 	  The device name, as to be set by wpa_s in the interface's
		 * 			   softMAC.
		 * @services: The services, as to be registered at wpa_s for being
		 * 			   able to respond, in case of any regarding requests.
		 *
		 */
		void init(const std::string &name, const std::list<std::string> &services) throw (SupplicantHandleException);

		/**
		 * Initiates P2P_FIND command at wpa_s, i.e. it will set the hardware
		 * 	network interface into listen_state. Thus, the interface will send
		 * 	probe_request management frames and listen actively for on air
		 * 	probe_responses and other STAs management frames in general.
		 * On failure, escalates an exception.
		 *
		 */
		void findPeers() throw (SupplicantHandleException);

		/**
		 * Initiates P2P_FIND command at wpa_s for the time as specified by the
		 * 	respective value.
		 *
		 * @seconds: Time in seconds wpa_s will reside in its listen state.
		 *
		 */
		void findPeers(int seconds) throw (SupplicantHandleException);

		/**
		 * Stops P2P_FIND command at wpa_s.
		 *
		 */
		void findPeersStop() throw (SupplicantHandleException);

		/**
		 * This method requires some in-out references as parameters for being able to
		 * 	manage several call backs to external data structures.
		 * 	The method requires a control connection to wpa_s being set to monitor-mode.
		 * 	If so, it listens non-blocking at the respective wpa_s for any event
		 * 	message. Those are generally created unsolicited from the related command
		 * 	call, as their generation fully depends on receiving the required response
		 * 	frames on L2 and being processed by the local wpa_s.
		 *
		 * The method treats the following events, which may be created by the locally
		 * 	connected wpa_s. The wpa_s is required to be in monitor mode.
		 *
		 * 	P2P_EVENT_DEVICE_FOUND
		 *	P2P_EVENT_GROUP_STARTED
		 *	AP_STA_CONNECTED
		 *	AP_STA_DISCONNECTED
		 *	P2P_EVENT_GROUP_REMOVED
		 *	P2P_EVENT_GO_NEG_REQUEST
		 *	P2P_EVENT_SERV_DISC_REQ
		 *	P2P_EVENT_SERV_DISC_RESP
		 *
		 * @&peers:		  Reference to a list<Peer> object for managing any found, i.e.
		 * 				   especially any fully discovered peer.
		 * @&connections: The reference to a list<Connection> object which is supposed to
		 * 				   store and manage any established connection.
		 * @&services:	  Reference to a list<std::string> which enables SupplicantHandle to
		 * 				   know all locally available services.
		 * @&sdreq_id:	  Reference to another list<std::string> which collects service request
		 * 				   id's. Those id's are generated by wpa_s for any actually on air
		 * 				   service request transmitted through ::requestService() and
		 * 				   required for canceling each of it through ::requestServiceCancel().
		 * @&ext_if:	  The reference to the actual call back interface needed to being
		 * 				   implement for properly using the library.
		 *
		 */
		void listen(std::list<Peer> &peers,
				std::list<Connection> &connections,
				std::list<std::string> &services,
				std::set<std::string> &sdreq_id,
				WifiP2PInterface &ext_if) throw (SupplicantHandleException);

		/**
		 * Initiates a upnp service request at wpa_s as fully broadcast, i.e. its
		 * 	destination address is 00:00:00:00:00:00.
		 *
		 * @service   The std::string to be requested for; according to upnp the this
		 * 			   std::string represents the ST-Field (Search_Target) of its
		 * 			   respective M-SEARCH request.
		 * @*sdreq_id Pointer enabling ::requestService() to call back a set<std::string>
		 * 			   and ::insert() the wpa_s' returned service_request_id.
		 * 			   This id is later needed by wpa_s to cancel the request. If not
		 * 			   canceled, the request will be broadcast potentially for ever
		 * 			   -- though no more considered (and replied) by peers, which were
		 * 			   able to handle it properly; others may be penetrated.
		 */
		void requestService(const std::string &service, std::set<std::string> &sdreq_id)
				throw (SupplicantHandleException);

		/**
		 * Requests a upnp service, at a specific destination peer.
		 * This method is especially meant to request the destination peer's name,
		 *  as registered per service.
		 *  Furthermore, one will get a service response whether the service is
		 *  registered at that peer's wpa_s or not.
		 * The whole procedure turns a peer (only MAC known) into a 'fully discovered'
		 * 	peer, with MAC and name known, in the case it holds the requested service.
		 * 	The name must be derived from the destination peer's automatically
		 * 	generated sd_response.
		 *
		 * @peer:	   The peer destined for the service request.
		 * @service:   The service in request.
		 * @*sdreq_id: Pointer at a list, where the per request corresponding
		 * 				will be pushed at sdreq_id. Required to cancel any requested
		 * 				service later.
		 *
		 */
		void requestService(const Peer &peer, const std::string &service, std::set<std::string> &sdreq_id)
				throw (SupplicantHandleException);

		/**
		 * Cancels a pending service request, according to its id at wpa_s.
		 *
		 * @sdreq_id: The corresponding ID required to cancel a pending service request.
		 *
		 */
		void requestServiceCancel(const std::string &sdreq_id) throw (SupplicantHandleException);

		/**
		 * Creates a peering between this local and wpa_s controlled WNIC and Peer
		 *  peer. The method uses WPS Push Button Configuration (PBC). wpa_s will
		 *  create a virtual WNIC per each connection which is going to be established.
		 *  The virtual interface will be called "p2p-<HW-IF-name>-<#count>".
		 *
		 * @peer: The peer to which wpa_s should initiate a connection.
		 *
		 */
		void connectToPeer(const Peer &peer) throw (SupplicantHandleException);

		/**
		 * By now, this method only handles to remove wpa_s' created virtual WNICs,
		 *  thus disconnecting both of a group's peers.
		 * This is sufficient, as SupplicantHandle::connectToPeer(Peer) does not deal
		 * 	with joining a P2P group, whether available, but just always creates
		 * 	exactly one peering between each two devices in a separate group.
		 *
		 * @conn: The Connection which stores the interface to be removed.
		 *
		 */
		void disconnect(const Connection &conn) throw (SupplicantHandleException);

		/**
		 * Unregisters all services from running wpa_s.
		 *
		 */
		bool flushServices() throw (SupplicantHandleException);

		/**
		 * Enables to get the file descriptor which may help in reporting whether
		 * 	event messages are locally available or not.
		 * 	The respective wpa_s is required to be in monitor_mode.
		 *
		 * Returns: Actual wpa_s file descriptor, i.e. the respective integer.
		 *
		 */
		int getFD() const throw (SupplicantHandleException);

	private:
		static const std::string TAG;

		bool monitor_mode;
		Logger &_logger;
		void *_handle;

		/**
		 * Sets SupplicantHandle in monitor mode by attaching it to wpa_s' domain
		 * 	socket.
		 * Initializes the attached domain sockets FileDescriptor as returned by
		 * 	the proper wpa_s control_i/f's function.
		 *
		 * Returns: true, if the monitor may be set. false, otherwise.
		 *
		 */
		bool setMonitorMode() throw (SupplicantHandleException);

		/**
		 * Method to set the device if actually allowed by the respective
		 * 	hardware driver.
		 *
		 * @name: 	The name as to be set for the device, controlled by this wpa_s.
		 * Returns: true, if device name is set; false, else.
		 *
		 */
		bool setDeviceName(const std::string &name) throw (SupplicantHandleException);

		/**
		 * Registers a service at the local wpa_s. By convention, this library
		 * 	is dealing with upnp as service discovery protocol with version tag
		 * 	equal to 10. The official upnp service-device-naming scheme is not
		 * 	used!
		 * The naming conventions for a registered service are
		 *
		 * 		<SERVICE_NAME>$<DEVICE_NAME>
		 *
		 * 	which may result e.g. in
		 *
		 * 		IBRDTN$SomeDTNNodesEID
		 *
		 * 	as a registered service at the local wpa_s.
		 *
		 * @name:	 The local stations device name.
		 * @service: The name of the to be registered service.
		 * Returns:	 true, if the service may be successfully registered.
		 *
		 */
		bool addService(const std::string &name, const std::string &service) throw (SupplicantHandleException);

		/**
		 * Method to be used to parse a certain command through a connected ctrl_i/f
		 *  connection to the respectively connected and running wpa_s.
		 *
		 * @cmd: 			  Command std::string, to be transmitted to wpa_s. See wpa_s
		 * 					   documentation for possible commands.
		 * 					  IT IS OF HIGHEST IMPORTANCE to handing over everything
		 * 					   except the actual command - which is only the very
		 * 					   first part of each such statement - and freely to be
		 * 					   defined names - e.g. an actual device name - in all-lower
		 * 					   case letters! Otherwise, wpa_s will fail executing
		 * 					   the command.
		 * @response_msg: 	  std::string object that will contain the reply of the command
		 * 					   after calling the wpa_s.
		 */
		void p2pCommand(const std::string &cmd, std::string &response_msg) throw (SupplicantHandleException);

		/**
		 * Decomposed the wpa_s message into an array of std::strings, with
		 * 	each array element representing one of the message's values.
		 * 	The first value within the returned std::string array represents
		 * 	the event type while the following depend on that type.
		 *
		 * @buffer: std::string awaited, representing the service response's
		 * 			 TLV data.
		 * @tok	  : std::string token by which to separate the input buffer.
		 * Returns: vector<std::string> of the separated buffer parts.
		 */
		std::vector<std::string> msgDecompose(const std::string &buf, const std::string &tok);

		/**
		 * Method created by Johannes Morgenroth in the context of the
		 * 	IBR common library.
		 * Divides a std::string into several substd::strings by a given delimiter.
		 *
		 * @token:  The delimiter searched for between each two characters.
		 * @data:	The to be divided original std::string.
		 * @max:	Maximum number of parts to divide std::string into.
		 * Returns:	The up divided original std::string as a vector<std::string>.
		 */
		std::vector<std::string> tokenize(const std::string &token, const std::string &data, size_t max) const;

		/**
		 * Converts hexadecimal input data to its proper ASCII coded
		 * 	std::string representation.
		 * Needs helper function SupplicantHandle::hexlookup().
		 *
		 * @std::string: The TLV received from a service discovery response.
		 * 			 That is only response frame's data, not its header.
		 * 			 Independently of wpa_s' specification, this method
		 * 			 may actually only deal with service entries at
		 * 			 opposite stations, which do not overflow the total
		 * 			 size of 65535 Byte, which equals FFFF as length.
		 * Return:	A std::string representation of the TLV input data.
		 *
		 */
		std::string getStringFromHexTLV(const std::string &tlv);

		/**
		 * Table lookup returning a short (decimal representation)
		 * 	accordingly to the input character (hex representation).
		 *
		 * @c:	   hex input character [0-9,a-f]
		 * Return: decimal equivalent [0-15]
		 *
		 */
		short hexlookup(char c);

		/**
		 * Checks whether a std::string is contained within another or not.
		 *
		 * @own:	 std::string representing locally registered service.
		 * @foreign: externally requested service as std::string representation.
		 * Returns:	 true, whether foreign is contained within own or not.
		 *
		 */
		bool matchingService(const std::string &own, const std::string &foreign);
	};
} /* namespace wifip2p */
#endif /* SUPPLICANTHANDLE_H_ */
