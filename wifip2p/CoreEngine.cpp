/*
 * CoreEngine.cpp
 *
 *  Created on: 06.02.2013
 *      Author: niels_w
 */

#include "wifip2p/CoreEngine.h"

using namespace std;

namespace wifip2p {

CoreEngine::CoreEngine(string ctrl_path, string name)
		: wpasup(false),
		  wpamon(true),
		  actual_state(ST_IDLE),
		  name(name),
		  ctrl_path(ctrl_path) {

}

CoreEngine::~CoreEngine() {
	// TODO Auto-generated destructor stub
}

/* Methods/Member functions >>
 *
 */
void CoreEngine::run() {
	wpasup.open(this->ctrl_path.c_str());
	wpamon.open(this->ctrl_path.c_str());
	wpasup.init(this->name, this->services);

	bool running = true;

	while (running) {

		switch(actual_state) {

		case ST_IDLE:
			do {
				if (!timer.isRunning())
					timer.setTimer(2, 0);

				wpamon.listen(&peers, &ext_if);

			} while(!timer.timeout());

			actual_state(ST_SCAN);

			break;

		case ST_SCAN:
			do {
				if (!timer.isRunning())
					timer.setTimer(1, 0);

				wpamon.listen(&peers, &ext_if);
				wpasup.findPeers();

			} while(!timer.timeout());

			wpasup.findPeersStop();

			if (!peers.empty()) {
				actual_state(ST_SREQ);
			} else {
				actual_state(ST_IDLE);
			}

			break;

		case ST_SREQ:
			do {
				if (!timer.isRunning())
					timer.setTimer(1, 0);

				wpamon.listen(&peers, &ext_if);

				list<string>::iterator it = services.begin();

				/** TODO
				 * 	The sdreq_id list<string> is newly defined. This list needs to
				 *   be filled with each service request id generated and solicit
				 *   to being received by the none-monitoring wpasup connection.
				 * 	Each id value is needed to cancel any on air request; otherwise,
				 *   they may be send transmitted (and received by neighboring STA)
				 *   forever.
				 *
				 * 	How does receiving such an immediate response actually works?!
				 *   Are they recognized at wpamon?
				 *   Are they send exactly after every command call sent?
				 *   The 'how' will take effect on the next source part.
				 *  REMEMBERED ANSWER TO THIS >>
				 *  	The direct response is pointed at within p2pCommand
				 *  	using wpa_ctrl_request() and its callback parameters.
				 *
				 */
				for (; it != services.end(); ++it) {
					wpasup.requestService(*it);
					/** TODO
					 * 	Additionally to ::listen(), which awaits unsolicited wpa_s
					 * 	 messages at the connected wpamon,
					 * 	 ::receiveMsg(list<string> *sdreq_id) may catch the immediate
					 * 	 feedback generated by wpa_s after executing a command.
					 * 	This message then needs to be decomposed, in order to isolate
					 * 	 the sd_req_id to be stored in the corresponding list.
					 *	The list may then be used to cancel each service request by
					 *	 SupplicantHandle::requestServiceCancel(string sdreq_id)
					 */
					wpasup.receiveMsg(&sdreq_id);

				}

			} while();

			break;

		case ST_CONN:

			break;

		default:

			break;

		}
	}
}

void CoreEngine::connect(wifip2p::Peer peer) {
	;
}

void CoreEngine::disconnect(wifip2p::Connection connection) {
	;
}

void CoreEngine::disconnect(wifip2p::NetworkIntf nic) {
	;
}

void CoreEngine::disconnect(wifip2p::Peer peer) {
	;
}

void CoreEngine::setName(string name) {
	this->name = name;
	this->initialize();
}

/**
 * TODO Verify that calling ::initialize()::open() on already opened _handle
 *  connections is not leading to any error.
 *  Maybe to define and implement a method *terminate()*, closing all the connection
 *  of the respective wpasup and wpamon _handles.
 */
void CoreEngine::reinitialize(string ctrl_path, list<string> services) throw (CoreEngineException) {
	this->ctrl_path = ctrl_path;
	this->services = services;
	try {
		this->initialize();
	} catch (CoreEngineException &ex) {
		throw CoreEngineException(ex.what());
	}
}

bool CoreEngine::addService(string service) {
	this->services.push_back(service);
}

bool CoreEngine::addService(list<string> services) {
	;
}

void CoreEngine::initialize() throw (CoreEngineException) {

	try {
		this->wpasup.open(this->ctrl_path.c_str());
		this->wpamon.open(this->ctrl_path.c_str());
	} catch (SupplicantHandleException &ex) {
		throw CoreEngineException("Error initializing handles: " + ex.what());
	}

	this->actual_state = ST_IDLE;

	//this->wpasup.init(name, services);

}


} /* namespace wifip2p */
